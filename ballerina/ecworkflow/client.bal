// AUTO-GENERATED FILE. DO NOT MODIFY.
// This file is auto-generated by the Ballerina OpenAPI tool.

// Copyright (c) 2025, WSO2 LLC. (http://www.wso2.org).
//
// WSO2 LLC. licenses this file to you under the Apache License,
// Version 2.0 (the "License"); you may not use this file except
// in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.

import ballerina/data.jsondata;
import ballerina/http;
import ballerinax/sap;

# You can use these APIs to access data of employees workflow requests and and other workflow data such as current status.
#
# You can find your company's API server in [List of API Servers in SAP SuccessFactors.](https://help.sap.com/viewer/d599f15995d348a1b45ba5603e2aba9b/LATEST/en-US/af2b8d5437494b12be88fe374eba75b6.html)
public isolated client class Client {
    final sap:Client clientEp;

    # Gets invoked to initialize the `connector`.
    #
    # + config - The configurations to be used when initializing the `connector` 
    # + serviceUrl - URL of the target service 
    # + return - An error if connector initialization failed 
    public isolated function init(ConnectionConfig config, string hostname, int port = 443) returns error? {
        string serviceUrl = string `https://${hostname}:${port}/successfactors/odata/v2`;
        http:ClientConfiguration httpClientConfig = {auth: config.auth, httpVersion: config.httpVersion, http1Settings: config.http1Settings, http2Settings: config.http2Settings, timeout: config.timeout, forwarded: config.forwarded, followRedirects: config.followRedirects, poolConfig: config.poolConfig, cache: config.cache, compression: config.compression, circuitBreaker: config.circuitBreaker, retryConfig: config.retryConfig, cookieConfig: config.cookieConfig, responseLimits: config.responseLimits, secureSocket: config.secureSocket, proxy: config.proxy, socketConfig: config.socketConfig, validation: config.validation, laxDataBinding: config.laxDataBinding};
        self.clientEp = check new (serviceUrl, httpClientConfig);
    }

    # Get entities from MyPendingWorkflow
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listMyPendingWorkflows(map<string|string[]> headers = {}, *ListMyPendingWorkflowsQueries queries) returns Wrapper|error {
        string resourcePath = string `/MyPendingWorkflow`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entity from MyPendingWorkflow by key
    #
    # + wfRequestId - key: wfRequestId
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getMyPendingWorkflow(string wfRequestId, map<string|string[]> headers = {}, *GetMyPendingWorkflowQueries queries) returns MyPendingWorkflow_1|error {
        string resourcePath = string `/MyPendingWorkflow('${getEncodedUri(wfRequestId)}')`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entities from WfRequestParticipator
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listWfRequestParticipators(map<string|string[]> headers = {}, *ListWfRequestParticipatorsQueries queries) returns Wrapper_1|error {
        string resourcePath = string `/WfRequestParticipator`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entity from WfRequestParticipator by key
    #
    # + wfRequestParticipatorId - key: wfRequestParticipatorId
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getWfRequestParticipator(int wfRequestParticipatorId, map<string|string[]> headers = {}, *GetWfRequestParticipatorQueries queries) returns WfRequestParticipator_1|error {
        string resourcePath = string `/WfRequestParticipator(${getEncodedUri(wfRequestParticipatorId)})`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entities from WorkflowAllowedActionList
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listWorkflowAllowedActionLists(map<string|string[]> headers = {}, *ListWorkflowAllowedActionListsQueries queries) returns Wrapper_2|error {
        string resourcePath = string `/WorkflowAllowedActionList`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entity from WorkflowAllowedActionList by key
    #
    # + wfRequestId - key: wfRequestId
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getWorkflowAllowedActionList(int wfRequestId, map<string|string[]> headers = {}, *GetWorkflowAllowedActionListQueries queries) returns WorkflowAllowedActionList_1|error {
        string resourcePath = string `/WorkflowAllowedActionList(${getEncodedUri(wfRequestId)})`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entities from AlertMessage
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listAlertMessages(map<string|string[]> headers = {}, *ListAlertMessagesQueries queries) returns Wrapper_3|error {
        string resourcePath = string `/AlertMessage`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add new entity to AlertMessage
    #
    # + headers - Headers to be sent with the request 
    # + payload - New entity 
    # + return - Created entity 
    remote isolated function createAlertMessage(AlertMessage payload, map<string|string[]> headers = {}) returns Created\ AlertMessage|error {
        string resourcePath = string `/AlertMessage`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get entity from AlertMessage by key
    #
    # + externalCode - key: externalCode
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getAlertMessage(string externalCode, map<string|string[]> headers = {}, *GetAlertMessageQueries queries) returns AlertMessage_1|error {
        string resourcePath = string `/AlertMessage('${getEncodedUri(externalCode)}')`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update entity in AlertMessage
    #
    # + externalCode - key: externalCode
    # + headers - Headers to be sent with the request 
    # + payload - New property values 
    # + return - Success 
    remote isolated function updateAlertMessage(string externalCode, Modified\ AlertMessage payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/AlertMessage('${getEncodedUri(externalCode)}')`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete entity from AlertMessage
    #
    # + externalCode - key: externalCode
    # + headers - Headers to be sent with the request 
    # + return - Success 
    remote isolated function deleteAlertMessage(string externalCode, DeleteAlertMessageHeaders headers = {}) returns error? {
        string resourcePath = string `/AlertMessage('${getEncodedUri(externalCode)}')`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Get entities from WfRequestComments
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listWfRequestCommentss(map<string|string[]> headers = {}, *ListWfRequestCommentssQueries queries) returns Wrapper_4|error {
        string resourcePath = string `/WfRequestComments`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entity from WfRequestComments by key
    #
    # + wfRequestCommentId - key: wfRequestCommentId
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getWfRequestComments(int wfRequestCommentId, map<string|string[]> headers = {}, *GetWfRequestCommentsQueries queries) returns WfRequestComments_1|error {
        string resourcePath = string `/WfRequestComments(${getEncodedUri(wfRequestCommentId)})`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entities from WfRequestStep
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listWfRequestSteps(map<string|string[]> headers = {}, *ListWfRequestStepsQueries queries) returns Wrapper_5|error {
        string resourcePath = string `/WfRequestStep`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entity from WfRequestStep by key
    #
    # + wfRequestStepId - key: wfRequestStepId
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getWfRequestStep(int wfRequestStepId, map<string|string[]> headers = {}, *GetWfRequestStepQueries queries) returns WfRequestStep_1|error {
        string resourcePath = string `/WfRequestStep(${getEncodedUri(wfRequestStepId)})`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entities from AutoDelegateDetail
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listAutoDelegateDetails(map<string|string[]> headers = {}, *ListAutoDelegateDetailsQueries queries) returns Wrapper_6|error {
        string resourcePath = string `/AutoDelegateDetail`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Add new entity to AutoDelegateDetail
    #
    # + headers - Headers to be sent with the request 
    # + payload - New entity 
    # + return - Created entity 
    remote isolated function createAutoDelegateDetail(AutoDelegateDetail payload, map<string|string[]> headers = {}) returns Created\ AutoDelegateDetail|error {
        string resourcePath = string `/AutoDelegateDetail`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get entity from AutoDelegateDetail by key
    #
    # + AutoDelegateConfig_delegator - key: AutoDelegateConfig_delegator
    # + externalCode - key: externalCode
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getAutoDelegateDetail(string AutoDelegateConfig_delegator, string externalCode, map<string|string[]> headers = {}, *GetAutoDelegateDetailQueries queries) returns AutoDelegateDetail_1|error {
        string resourcePath = string `/AutoDelegateDetail(AutoDelegateConfig_delegator='${getEncodedUri(AutoDelegateConfig_delegator)}',externalCode='${getEncodedUri(externalCode)}')`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Update entity in AutoDelegateDetail
    #
    # + AutoDelegateConfig_delegator - key: AutoDelegateConfig_delegator
    # + externalCode - key: externalCode
    # + headers - Headers to be sent with the request 
    # + payload - New property values 
    # + return - Success 
    remote isolated function updateAutoDelegateDetail(string AutoDelegateConfig_delegator, string externalCode, Modified\ AutoDelegateDetail payload, map<string|string[]> headers = {}) returns error? {
        string resourcePath = string `/AutoDelegateDetail(AutoDelegateConfig_delegator='${getEncodedUri(AutoDelegateConfig_delegator)}',externalCode='${getEncodedUri(externalCode)}')`;
        http:Request request = new;
        json jsonBody = jsondata:toJson(payload);
        request.setPayload(jsonBody, "application/json");
        return self.clientEp->put(resourcePath, request, headers);
    }

    # Delete entity from AutoDelegateDetail
    #
    # + AutoDelegateConfig_delegator - key: AutoDelegateConfig_delegator
    # + externalCode - key: externalCode
    # + headers - Headers to be sent with the request 
    # + return - Success 
    remote isolated function deleteAutoDelegateDetail(string AutoDelegateConfig_delegator, string externalCode, DeleteAutoDelegateDetailHeaders headers = {}) returns error? {
        string resourcePath = string `/AutoDelegateDetail(AutoDelegateConfig_delegator='${getEncodedUri(AutoDelegateConfig_delegator)}',externalCode='${getEncodedUri(externalCode)}')`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Get entities from AutoDelegateConfig
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listAutoDelegateConfigs(map<string|string[]> headers = {}, *ListAutoDelegateConfigsQueries queries) returns json|error {
        string resourcePath = string `/AutoDelegateConfig`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entity from AutoDelegateConfig by key
    #
    # + delegator - key: delegator
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getAutoDelegateConfig(string delegator, map<string|string[]> headers = {}, *GetAutoDelegateConfigQueries queries) returns json|error {
        string resourcePath = string `/AutoDelegateConfig('${getEncodedUri(delegator)}')`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Delete entity from AutoDelegateConfig
    #
    # + delegator - key: delegator
    # + headers - Headers to be sent with the request 
    # + return - Success 
    remote isolated function deleteAutoDelegateConfig(string delegator, DeleteAutoDelegateConfigHeaders headers = {}) returns error? {
        string resourcePath = string `/AutoDelegateConfig('${getEncodedUri(delegator)}')`;
        map<string|string[]> httpHeaders = http:getHeaderMap(headers);
        return self.clientEp->delete(resourcePath, headers = httpHeaders);
    }

    # Get entities from EmpWfRequest
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listEmpWfRequests(map<string|string[]> headers = {}, *ListEmpWfRequestsQueries queries) returns Wrapper_8|error {
        string resourcePath = string `/EmpWfRequest`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entity from EmpWfRequest by key
    #
    # + empWfRequestId - key: empWfRequestId
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getEmpWfRequest(int empWfRequestId, map<string|string[]> headers = {}, *GetEmpWfRequestQueries queries) returns EmpWfRequest_1|error {
        string resourcePath = string `/EmpWfRequest(${getEncodedUri(empWfRequestId)})`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entities from WfRequest
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entities 
    remote isolated function listWfRequests(map<string|string[]> headers = {}, *ListWfRequestsQueries queries) returns Wrapper_9|error {
        string resourcePath = string `/WfRequest`;
        map<Encoding> queryParamEncoding = {"$orderby": {style: FORM, explode: false}, "$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Get entity from WfRequest by key
    #
    # + wfRequestId - key: wfRequestId
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Retrieved entity 
    remote isolated function getWfRequest(int wfRequestId, map<string|string[]> headers = {}, *GetWfRequestQueries queries) returns WfRequest_1|error {
        string resourcePath = string `/WfRequest(${getEncodedUri(wfRequestId)})`;
        map<Encoding> queryParamEncoding = {"$select": {style: FORM, explode: false}, "$expand": {style: FORM, explode: false}};
        resourcePath = resourcePath + check getPathForQueryParam(queries, queryParamEncoding);
        return self.clientEp->get(resourcePath, headers);
    }

    # Invoke action approveWfRequest
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success 
    remote isolated function createapproveWfRequest(map<string|string[]> headers = {}, *CreateapproveWfRequestQueries queries) returns Result|error {
        string resourcePath = string `/approveWfRequest`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Invoke action commentWfRequest
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success 
    remote isolated function createcommentWfRequest(map<string|string[]> headers = {}, *CreatecommentWfRequestQueries queries) returns Result|error {
        string resourcePath = string `/commentWfRequest`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Invoke action rejectWfRequest
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success 
    remote isolated function createrejectWfRequest(map<string|string[]> headers = {}, *CreaterejectWfRequestQueries queries) returns Result|error {
        string resourcePath = string `/rejectWfRequest`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Invoke action sendbackWfRequest
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success 
    remote isolated function createsendbackWfRequest(map<string|string[]> headers = {}, *CreatesendbackWfRequestQueries queries) returns Result|error {
        string resourcePath = string `/sendbackWfRequest`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Get pending data of a workflow request
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success 
    remote isolated function creategetWorkflowPendingData(map<string|string[]> headers = {}, *CreategetWorkflowPendingDataQueries queries) returns Result_1|error {
        string resourcePath = string `/getWorkflowPendingData`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }

    # Invoke action withdrawWfRequest
    #
    # + headers - Headers to be sent with the request 
    # + queries - Queries to be sent with the request 
    # + return - Success 
    remote isolated function createwithdrawWfRequest(map<string|string[]> headers = {}, *CreatewithdrawWfRequestQueries queries) returns Result|error {
        string resourcePath = string `/withdrawWfRequest`;
        resourcePath = resourcePath + check getPathForQueryParam(queries);
        http:Request request = new;
        return self.clientEp->post(resourcePath, request, headers);
    }
}
